
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title> | LinkedList&#39;s Blog</title>
        <meta name="author" content="Ding Li" />
        <meta name="description" content="This is blog for Linkedlist771, mainly record some learning notes, thank you for your visit!" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>LINKEDLIST&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;LINKEDLIST&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/7/22
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>为了解决这个问题，我们提出了另一种简单而有效的条件化方法：在数据加载期间，我们均匀地采样裁剪坐标$c_{\text {top }}$ 和 $c_{\text {left }}$（分别指定从左上角沿高度和宽度轴裁剪的像素数量的整数），并通过傅立叶特征嵌入将它们作为条件参数输入到模型中，类似于上述的大小条件化。然后，连接的嵌入$\mathbf{c}<em>{\mathrm{crop}}$被用作额外的条件参数。我们强调，这种技术不仅限于LDMs，可以用于任何DM。注意，裁剪和大小条件化可以轻松地结合起来。在这种情况下，我们在将其添加到UNet的时间步嵌入之前，沿着通道维度连接特征嵌入。算法1说明了在应用这种组合时，我们如何在训练期间采样$\mathbf{c}</em>{\text {crop }}$ 和 $\mathbf{c}_{\text {size }}$。</p>
<p>考虑到我们的经验是，大规模数据集平均来说是以对象为中心的，我们在推理期间设置$\left(c_{\text {top }}, c_{\text {left }}\right)&#x3D;$ $(0,0)$，从而从训练模型中获得以对象为中心的样本。</p>
<p>请参见图5的说明：通过调整$\left(c_{\text {top }}, c_{\text {left }}\right)$，我们可以成功地模拟推理期间的裁剪量。这是一种条件化增强的形式，已经在自回归模型[20]和最近的扩散模型[21]中以各种形式使用。</p>
<p>虽然其他方法，如数据分桶[31]，成功地解决了同样的任务，但我们仍然从裁剪引起的数据增强中受益，同时确保它不会渗入生成过程 - 我们实际上利用它来获得对图像合成过程的更多控制。此外，它易于实现，并且可以在训练期间在线应用，无需额外的数据预处理。</p>
<p>这个伪代码描述了一个用于图像处理的算法，它包括调整图像大小和裁剪图像的步骤。这个算法的目标是将输入的图像调整到指定的大小，并在需要的情况下进行裁剪。以下是对每一段的解释：</p>
<ol>
<li><p><strong>Require: Training dataset of images</strong> $\mathcal{D}$ <strong>, target image size for training</strong> $\boldsymbol{s}&#x3D;\left(h_{\text {tgt }}, w_{\text {tgt }}\right)$</p>
<p>这一段定义了算法的输入。需要一个图像的训练数据集$\mathcal{D}$，以及目标图像的大小$\boldsymbol{s}$，其中$h_{\text {tgt }}$和$w_{\text {tgt }}$分别代表目标图像的高度和宽度。</p>
</li>
<li><p><strong>Require: Resizing function</strong> $\boldsymbol{R}$ <strong>, cropping function function</strong> $\boldsymbol{C}$</p>
<p>这一段定义了两个函数，一个是用于调整图像大小的函数$\boldsymbol{R}$，另一个是用于裁剪图像的函数$\boldsymbol{C}$。</p>
</li>
<li><p><strong>Require: Model train step</strong> $\boldsymbol{T}$</p>
<p>这一段定义了模型训练的步骤函数$\boldsymbol{T}$。</p>
</li>
<li><p><strong>converged</strong> $\leftarrow$ <strong>False</strong></p>
<p>这一段初始化了一个名为”converged”的变量，其初始值为False。这个变量用于控制训练过程的结束，当模型收敛（即模型的训练误差不再显著下降或者达到预设的训练轮数）时，这个变量将被设置为True。</p>
</li>
<li><p><strong>while not converged do</strong></p>
<p>这一段开始了一个循环，只有当”converged”变量为False时，循环才会继续。也就是说，只要模型还没有收敛，就会继续执行循环中的步骤。</p>
</li>
<li><p><strong>x $\sim$ $\mathcal{D}$</strong></p>
<p>这一段从训练数据集$\mathcal{D}$中随机选择一个图像作为输入。</p>
</li>
<li><p><strong>$w_{\text {original }} \leftarrow \text { width }(x)$</strong></p>
<p><strong>$h_{\text {original }} \leftarrow \text { height }(x)$</strong></p>
<p>这两段获取了选定图像的原始宽度和高度。</p>
</li>
<li><p><strong>$\mathbf{c}<em>{\text {size }} \leftarrow\left(h</em>{\text {original }}, w_{\text {original }}\right)$</strong></p>
<p>这一段创建了一个向量$\mathbf{c}_{\text {size }}$，其中包含了图像的原始高度和宽度。</p>
</li>
<li><p><strong>x $\leftarrow$ $\boldsymbol{R}(x, \boldsymbol{s})$</strong></p>
<p>这一段使用调整大小的函数$\boldsymbol{R}$将图像调整到目标大小$\boldsymbol{s}$。</p>
</li>
<li><p><strong>if $h_{\text {original }} \leq w_{\text {original }}$ then</strong></p>
<p><strong>$c_{\text {left }} \sim \mathcal{U}\left(0, \text { width }(x)-s_w\right)$</strong></p>
<p><strong>$c_{\text {top }}&#x3D;0$</strong></p>
<p><strong>else if $h_{\text {original }}&gt;w_{\text {original }}$ then</strong></p>
<p><strong>$c_{\text {top }} \sim \mathcal{U}\left(0, \text { height }(x)-s_h\right)$</strong></p>
<p><strong>$c_{\text {left }}&#x3D;0$</strong></p>
<p><strong>end if</strong></p>
<p>这一段决定了裁剪的位置。如果原始图像的高度小于或等于宽度，那么将从左侧随机裁剪；如果原始图像的高度大于宽度，那么将从顶部随机裁剪。</p>
</li>
<li><p><strong>$\mathbf{c}<em>{\text {crop }} \leftarrow\left(c</em>{\text {top }}, c_{\text {left }}\right)$</strong></p>
<p>这一段创建了一个向量$\mathbf{c}_{\text {crop }}$，其中包含了裁剪的位置。</p>
</li>
<li><p><strong>x $\leftarrow$ $\boldsymbol{C}\left(x, \boldsymbol{s}, \mathbf{c}_{\text {crop }}\right)$</strong></p>
<p>这一段使用裁剪函数$\boldsymbol{C}$将图像裁剪到目标大小$\boldsymbol{s}$，并在指定的位置$\mathbf{c}_{\text {crop }}$进行裁剪。</p>
</li>
<li><p><strong>converged $\leftarrow$ $\boldsymbol{T}\left(x, \mathbf{c}<em>{\text {size }}, \mathbf{c}</em>{\mathrm{crop}}\right)$</strong></p>
<p>这一段执行模型训练的步骤，并将结果赋值给”converged”变量。如果模型已经收敛，那么”converged”变量将被设置为True，从而结束循环。</p>
</li>
<li><p><strong>end while</strong></p>
<p>这一段标志着循环的结束。当”converged”变量为True时，循环将结束，模型训练也就完成了。</p>
</li>
</ol>
<p>在这个伪代码中，$\mathbf{c}<em>{\mathrm{crop}}$ 是一个向量，它包含了裁剪图像的位置信息。具体来说，它由两个元素组成：$c</em>{\text {top }}$ 和 $c_{\text {left }}$。</p>
<p>$c_{\text {top }}$ 是从图像顶部开始裁剪的位置，$c_{\text {left }}$ 是从图像左侧开始裁剪的位置。这两个值决定了裁剪框的起始点。</p>
<p>在这个算法中，如果原始图像的高度小于或等于宽度，那么将从左侧随机裁剪，此时 $c_{\text {left }}$ 会从均匀分布 $\mathcal{U}\left(0, \text { width }(x)-s_w\right)$ 中随机取值，而 $c_{\text {top }}$ 则被设为 0。反之，如果原始图像的高度大于宽度，那么将从顶部随机裁剪，此时 $c_{\text {top }}$ 会从均匀分布 $\mathcal{U}\left(0, \text { height }(x)-s_h\right)$ 中随机取值，而 $c_{\text {left }}$ 则被设为 0。</p>
<p>这样，$\mathbf{c}_{\mathrm{crop}}$ 就定义了裁剪框的起始点，然后根据目标图像的大小 $\boldsymbol{s}$，就可以确定裁剪框的大小，从而完成图像的裁剪。</p>

    </div>
    
    
    
    
    
    
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 LinkedList&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Ding Li
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
