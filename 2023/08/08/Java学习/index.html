
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>Java学习 | LinkedList&#39;s Blog</title>
        <meta name="author" content="Ding Li" />
        <meta name="description" content="This is blog for Linkedlist771, mainly record some learning notes, thank you for your visit!" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>






<script src="https://cdn.staticfile.org/waline/2.14.8/waline.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.14.8/waline.min.css" />
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.14.8/waline-meta.min.css" />




<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>LINKEDLIST&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;LINKEDLIST&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1>Java学习</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/8
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java%E5%AD%A6%E4%B9%A0/" style="color: #ff7d73">Java学习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <blockquote>
<p>这篇博客主要用于记录在学习<code>Java</code>过程中遇到的问题，以及主要比较关键的知识点。</p>
</blockquote>
<span id="more"></span>

<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>在Java中，<code>instanceof</code>操作符用于测试一个对象是否是特定类或接口的实例。它是一个二元操作符，用于在运行时测试对象的类型。</p>
<p>以下是一个简单的示例来演示其用法：</p>
<pre><code class="java">class Animal &#123;&#125;
class Dog extends Animal &#123;&#125;
class Cat extends Animal &#123;&#125;

public class InstanceofDemo &#123;
    public static void main(String[] args) &#123;
        Animal a = new Animal();
        Dog d = new Dog();
        Cat c = new Cat();

        System.out.println(a instanceof Animal);  // true
        System.out.println(d instanceof Animal);  // true
        System.out.println(d instanceof Dog);     // true
        System.out.println(d instanceof Cat);     // false
        System.out.println(c instanceof Animal);  // true
        System.out.println(c instanceof Cat);     // true
    &#125;
&#125;
</code></pre>
<p>在上述代码中：</p>
<ul>
<li><code>Dog</code> 和 <code>Cat</code> 是 <code>Animal</code> 的子类。</li>
<li>我们创建了 <code>Animal</code>、<code>Dog</code> 和 <code>Cat</code> 的实例。</li>
<li>然后我们使用 <code>instanceof</code> 操作符来检查这些实例的类型。</li>
</ul>
<p>输出将是：</p>
<pre><code>true
true
true
false
true
true
</code></pre>
<p>需要记住的一些关键点：</p>
<ol>
<li><code>null</code> 不是任何东西的实例。所以，<code>null instanceof AnyClass</code> 总是返回 <code>false</code>。</li>
<li>如果 <code>instanceof</code> 操作符的左侧是右侧类的子类的实例，结果将为 <code>true</code>。例如，因为 <code>Dog</code> 是 <code>Animal</code> 的子类，所以 <code>d instanceof Animal</code> 返回 <code>true</code>。</li>
<li>如果两种类型不属于同一类型层次结构（即，它们除了 <code>Object</code> 之外没有共同的祖先），代码将无法编译。例如，尝试检查一个 <code>String</code> 是否是 <code>Dog</code> 的实例将导致编译错误。</li>
</ol>
<ul>
<li>static关键字</li>
</ul>
<p><code>static</code> 是 Java 中的一个关键字，它表示某个成员（可以是变量、方法、内部类等）不是与实例关联的，而是与类关联的。这意味着，无论创建多少个类的实例，<code>static</code> 成员都只有一份。</p>
<p>以下是 <code>static</code> 关键字的一些使用场景和示例：</p>
<ol>
<li><p><strong>静态变量</strong>：静态变量用于表示该类的所有实例共享的变量。它们通常用于存储应该由类的所有实例共享的信息。</p>
<pre><code class="java">class Student &#123;
    static int totalStudents = 0; // 静态变量
    int rollNo;

    Student() &#123;
        totalStudents++;
        rollNo = totalStudents;
    &#125;
&#125;
</code></pre>
<p>在上面的例子中，每当创建一个新的 <code>Student</code> 对象时，<code>totalStudents</code> 都会增加。所有的 <code>Student</code> 对象都共享同一个 <code>totalStudents</code> 变量。</p>
</li>
<li><p><strong>静态方法</strong>：静态方法是与类关联的，而不是与实例关联的。因此，它们不能访问类的非静态成员。</p>
<pre><code class="java">class MathUtils &#123;
    static int add(int a, int b) &#123;
        return a + b;
    &#125;
&#125;
</code></pre>
<p>在上面的例子中，<code>add</code> 方法是静态的，所以你可以不创建 <code>MathUtils</code> 的对象就直接调用它，如 <code>MathUtils.add(1, 2)</code>。</p>
</li>
<li><p><strong>静态块</strong>：这是一个特殊的代码块，只在类加载时执行一次。</p>
<pre><code class="java">class Test &#123;
    static &#123;
        System.out.println(&quot;Static block executed!&quot;);
    &#125;
&#125;
</code></pre>
<p>在上面的例子中，当你第一次访问这个类（例如，创建一个对象或访问其静态成员）时，静态块会被执行。</p>
</li>
<li><p><strong>静态内部类</strong>：这是定义在另一个类内部的静态类。它可以访问外部类的静态成员，但不能访问其非静态成员。</p>
<pre><code class="java">class Outer &#123;
    static int x = 10;

    static class Inner &#123;
        void display() &#123;
            System.out.println(&quot;Value of x: &quot; + x);
        &#125;
    &#125;
&#125;
</code></pre>
<p>在上面的例子中，<code>Inner</code> 是一个静态内部类，它可以访问 <code>Outer</code> 类的静态变量 <code>x</code>。</p>
</li>
</ol>
<p>总的来说，<code>static</code> 关键字在 Java 中非常有用，它允许我们创建与类关联的成员，而不是与单个实例关联的成员。这在创建工具方法、常量或需要由所有实例共享的变量时特别有用。</p>
<p>当然可以，我会尽量简化说明。</p>
<p>在 Java 中，<code>static</code> 关键字的主要作用是告诉程序：“这个东西属于整个类，而不仅仅是某个对象”。</p>
<p>想象一下学校的教室。每个学生都有自己的书包，这就像每个对象都有自己的变量。但教室里的黑板是共享的，所有学生都使用同一个黑板。在这个比喻中，黑板就像是一个 <code>static</code> 变量，它属于整个“教室”类，而不是单个“学生”。</p>
<p>以下是 <code>static</code> 的几个主要用途：</p>
<ol>
<li><p><strong>静态变量</strong>：这是一个“共享”变量，所有对象都使用同一个。例如，所有学生共享同一个黑板。</p>
</li>
<li><p><strong>静态方法</strong>：这是一个不特定于任何对象的方法。你不需要一个对象就可以调用它。例如，学校的规定可能适用于所有学生，而不仅仅是一个。</p>
</li>
<li><p><strong>静态块</strong>：当你首次访问一个类时，这段代码会运行一次。想象一下，每天早上教室的门第一次打开时，灯就会自动亮起。这就是静态块的作用。</p>
</li>
<li><p><strong>静态内部类</strong>：这是一个属于外部类的类，但它不依赖于外部类的特定对象。就像学校里的特定班级，它属于学校，但不依赖于特定的学生。</p>
</li>
</ol>
<p>简而言之，<code>static</code> 就是一个表示“共享”或“全局”的标志。当你看到 <code>static</code>，你可以想象这个东西是共享的，所有对象都可以访问它，而不仅仅是一个。</p>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote>
<p>在Java SE中，<code>abstract</code>关键字用于声明抽象类或抽象方法。抽象类是不能实例化的类，而抽象方法是没有具体实现的方法。这些抽象元素主要用于作为其他类的基础，以实现代码复用和设计模式。</p>
<p>如果继承的子类不为<code>抽象类</code>则必须重写(<code>override</code>)这个抽象方法。</p>
</blockquote>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种不能被实例化的类。它可能包含一些抽象方法和非抽象方法。</p>
<pre><code class="java">public abstract class Animal &#123;
    public abstract void makeSound();
    
    public void eat() &#123;
        System.out.println(&quot;This animal eats food.&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>抽象方法是没有方法体的方法，也就是说，它没有具体的实现。子类必须提供该方法的实现，除非子类也是抽象类。</p>
<pre><code class="java">public abstract void makeSound();
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用抽象类和抽象方法的简单示例：</p>
<pre><code class="java">public abstract class Animal &#123;
    public abstract void makeSound();

    public void sleep() &#123;
        System.out.println(&quot;The animal is sleeping.&quot;);
    &#125;
&#125;

public class Dog extends Animal &#123;
    public void makeSound() &#123;
        System.out.println(&quot;The dog barks.&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Animal myAnimal = new Dog();
        myAnimal.makeSound();
        myAnimal.sleep();
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>Animal</code>是一个抽象类，它有一个抽象方法<code>makeSound()</code>和一个普通方法<code>sleep()</code>。<code>Dog</code>类继承了<code>Animal</code>类，并提供了<code>makeSound()</code>方法的具体实现。</p>
<p>这样，当我们创建一个<code>Dog</code>对象并赋值给<code>Animal</code>类型的变量时，我们可以调用<code>makeSound()</code>和<code>sleep()</code>方法，而具体的<code>makeSound()</code>实现是由<code>Dog</code>类提供的。</p>
<p>希望这些信息能帮助你更好地理解Java SE中<code>abstract</code>关键字的用法。</p>
<ul>
<li>抽象类不能<code>new</code>， 只能靠子类来约束。</li>
<li>抽象类可以用普通方法</li>
<li>抽象方法必须在抽象类里面</li>
</ul>
<p>在Java中，抽象类是可以有构造函数（constructor）的。尽管你不能直接实例化一个抽象类，但当你创建一个继承自抽象类的子类的实例时，抽象类的构造函数会被调用。这通常用于执行一些初始化操作，或者设置抽象类中定义的一些字段。</p>
<h3 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h3><ol>
<li><p><strong>初始化抽象类字段</strong>：抽象类可以有字段（成员变量），并且这些字段可能需要初始化。构造函数是一个很好的地方来进行这种初始化。</p>
</li>
<li><p><strong>代码复用</strong>：如果所有继承自抽象类的子类都需要进行某种相同的初始化操作，那么你可以将这些操作放在抽象类的构造函数中，以避免代码重复。</p>
</li>
<li><p><strong>强制执行某些操作</strong>：通过在抽象类的构造函数中执行某些操作，你可以确保每个子类在实例化时都会执行这些操作，这有助于维护对象的一致性。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，展示了抽象类中构造函数的用法：</p>
<pre><code class="java">public abstract class Animal &#123;
    protected String name;

    public Animal(String name) &#123;
        this.name = name;
    &#125;

    public abstract void makeSound();
&#125;

public class Dog extends Animal &#123;
    public Dog(String name) &#123;
        super(name);
    &#125;

    public void makeSound() &#123;
        System.out.println(name + &quot; says: Woof, woof!&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Animal myAnimal = new Dog(&quot;Buddy&quot;);
        myAnimal.makeSound();  // Output: Buddy says: Woof, woof!
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>Animal</code>是一个抽象类，它有一个构造函数，用于初始化<code>name</code>字段。<code>Dog</code>类继承了<code>Animal</code>类，并通过<code>super(name);</code>调用了<code>Animal</code>类的构造函数，以确保<code>name</code>字段被正确地初始化。</p>
<p>这样，当你创建一个<code>Dog</code>对象时，<code>Animal</code>的构造函数会被调用，<code>name</code>字段会被初始化，然后<code>makeSound()</code>方法会输出相应的信息。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p> Java SE（Java Platform, Standard Edition）中的接口是一种非常重要的编程构造。接口用于定义对象应该如何进行交互，但不提供实现细节。这样，任何实现了该接口的类都必须提供接口中声明的方法的具体实现。</p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个简单的Java接口示例：</p>
<pre><code class="java">public interface Animal &#123;
    void makeSound();
    void eat();
&#125;
</code></pre>
<p>这里，<code>Animal</code> 接口定义了两个方法：<code>makeSound()</code> 和 <code>eat()</code>。任何实现了 <code>Animal</code> 接口的类都必须提供这两个方法的实现。</p>
<pre><code class="java">public class Dog implements Animal &#123;
    @Override
    public void makeSound() &#123;
        System.out.println(&quot;Woof Woof&quot;);
    &#125;

    @Override
    public void eat() &#123;
        System.out.println(&quot;Eating dog food&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>Dog</code> 类实现了 <code>Animal</code> 接口，并提供了 <code>makeSound()</code> 和 <code>eat()</code> 方法的具体实现。</p>
<h3 id="使用接口的好处"><a href="#使用接口的好处" class="headerlink" title="使用接口的好处"></a>使用接口的好处</h3><ol>
<li><strong>多态性</strong>：接口允许多态性，这意味着你可以使用接口类型来引用任何实现了该接口的对象。</li>
<li><strong>解耦</strong>：接口提供了一种方式来分离接口和实现，使得你可以在不影响客户端代码的情况下更改实现。</li>
<li><strong>可扩展性</strong>：通过接口，你可以轻松地添加新的方法和功能，而不需要更改现有的代码。</li>
</ol>
<ul>
<li>实现了接口的类，就需要重写接口的方法</li>
<li>接口可以实现伪多继承，类只能单继承</li>
</ul>
<p>当一个类要实现一个或多个接口时，它使用 <code>implements</code> 关键字。这也是Java中实现多继承的一种方式，因为一个类可以实现多个接口。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code class="java">public interface Movable &#123;
    void move();
&#125;

public interface Eatable &#123;
    void eat();
&#125;

public class Animal implements Movable, Eatable &#123;
    @Override
    public void move() &#123;
        System.out.println(&quot;Animal moves&quot;);
    &#125;

    @Override
    public void eat() &#123;
        System.out.println(&quot;Animal eats&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>Animal</code> 类通过使用 <code>implements</code> 关键字实现了 <code>Movable</code> 和 <code>Eatable</code> 接口。这样，<code>Animal</code> 类就必须提供这两个接口中所有方法的具体实现。</p>
<p>这是Java中支持多继承的一种方式，但请注意，这并不是传统意义上的多继承，因为接口不提供方法的具体实现（除非是Java 8+中的默认方法）。</p>
<p>总结一下：</p>
<ul>
<li>使用 <code>implements</code> 关键字，一个类可以实现多个接口。</li>
<li>这是Java中实现多继承的唯一方式。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在Java中，一个类可以定义在另一个类的内部，这样的类被称为内部类（Inner Class）。内部类提供了更好的封装和更高的可读性，因为它可以直接访问外部类的所有成员（包括私有成员）。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><strong>成员内部类</strong>：定义在类的成员级别，与字段、方法和构造函数同级。</li>
<li><strong>局部内部类</strong>：定义在一个方法或作用域内。</li>
<li><strong>匿名内部类</strong>：没有名称的局部内部类。</li>
<li><strong>静态内部类</strong>：用<code>static</code>关键字定义的内部类。</li>
</ol>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><pre><code class="java">public class OuterClass &#123;
    private int x = 10;

    class InnerClass &#123;
        public void display() &#123;
            System.out.println(&quot;Value of x: &quot; + x);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><pre><code class="java">public class OuterClass &#123;
    public void myMethod() &#123;
        class LocalInnerClass &#123;
            public void display() &#123;
                System.out.println(&quot;Inside Local Inner Class&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><pre><code class="java">new Thread(new Runnable() &#123;
    public void run() &#123;
        System.out.println(&quot;Thread running&quot;);
    &#125;
&#125;).start();
</code></pre>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="java">public class OuterClass &#123;
    static int x = 10;

    static class StaticInnerClass &#123;
        public void display() &#123;
            System.out.println(&quot;Value of x: &quot; + x);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>逻辑封装</strong>：如果两个类的逻辑紧密相关，将一个类定义为另一个类的内部类有助于封装。</li>
<li><strong>增加可读性和维护性</strong>：内部类将相关的功能组织在一起，使代码更易读和维护。</li>
<li><strong>访问外部类成员</strong>：内部类可以访问外部类的所有成员，包括私有成员。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>访问修饰符</strong>：内部类可以有访问修饰符（<code>public</code>, <code>protected</code>, <code>private</code>），或者使用包级访问。</li>
<li><strong>生命周期</strong>：内部类的实例总是依赖于外部类的实例，除非它是一个静态内部类。</li>
</ol>
<h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p><img src="/../images/image-20230906155438859.png" alt="image-20230906155438859"></p>
<p>在Java中，异常（Exception）是运行时错误的一种对象表示，用于标识程序中的问题。Java提供了一个完善的异常处理机制，允许你捕获和处理这些错误，以便程序能够以更加优雅的方式处理问题，而不是崩溃或产生不可预测的结果。</p>
<h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ol>
<li><p><strong>检查型异常（Checked Exceptions）</strong>：这些是必须显式处理（或者声明抛出）的异常，例如<code>IOException</code>、<code>SQLException</code>等。</p>
</li>
<li><p><strong>运行时异常（Runtime Exceptions）</strong>：这些异常通常表示编程错误，如<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等。运行时异常是不需要显式处理的。</p>
</li>
<li><p><strong>错误（Errors）</strong>：这些是严重的异常情况，通常与系统级别的问题有关，如<code>OutOfMemoryError</code>。一般来说，应用程序不应尝试捕获这些错误。</p>
</li>
</ol>
<h3 id="异常处理关键字"><a href="#异常处理关键字" class="headerlink" title="异常处理关键字"></a>异常处理关键字</h3><ol>
<li><strong>try</strong>：用于包围可能抛出异常的代码块。</li>
<li><strong>catch</strong>：用于捕获和处理特定类型的异常。</li>
<li><strong>finally</strong>：用于执行一定会被执行的代码，无论是否捕获到异常。</li>
<li><strong>throw</strong>：用于显式地抛出一个异常。</li>
<li><strong>throws</strong>：用于在方法签名中声明一个方法可能会抛出哪些类型的异常。</li>
</ol>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的异常处理示例：</p>
<pre><code class="java">public class ExceptionExample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            int result = divide(10, 0);
            System.out.println(&quot;Result: &quot; + result);
        &#125; catch (ArithmeticException e) &#123;
            System.out.println(&quot;Cannot divide by zero: &quot; + e.getMessage());
        &#125; finally &#123;
            System.out.println(&quot;This block will always execute.&quot;);
        &#125;
    &#125;

    public static int divide(int a, int b) throws ArithmeticException &#123;
        if (b == 0) &#123;
            throw new Arith
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>divide</code>方法可能会抛出<code>ArithmeticException</code>，这是一个运行时异常。<code>main</code>方法中的<code>try-catch-finally</code>结构用于捕获和处理这个异常。</p>
<h3 id="常见用途和最佳实践"><a href="#常见用途和最佳实践" class="headerlink" title="常见用途和最佳实践"></a>常见用途和最佳实践</h3><ol>
<li><strong>资源清理</strong>：使用<code>finally</code>块来确保资源（如文件、数据库连接等）得到正确的清理。</li>
<li><strong>异常链</strong>：当捕获一个异常并抛出另一个异常时，保留原始异常的信息。</li>
<li><strong>自定义异常</strong>：对于特定于应用的异常情况，可以创建自定义的异常类。</li>
<li><strong>不要滥用异常</strong>：异常应该用于异常情况，而不是用于普通的控制流。</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>设计模式是软件工程中用于解决常见设计问题的一种最佳实践。它们是解决特定问题的模板，可以帮助开发者编写更加可维护、可读和可重用的代码。设计模式通常分为三大类：</p>
<ol>
<li><p>创建型模式（Creational Patterns）：这些模式用于创建对象，而不是直接实例化对象。这样可以更灵活地控制对象的创建过程。例如，单例模式、工厂模式等。</p>
</li>
<li><p>结构型模式（Structural Patterns）：这些模式用于设计对象和类的结构，以便它们能更好地工作在一起。例如，适配器模式、装饰器模式等。</p>
</li>
<li><p>行为型模式（Behavioral Patterns）：这些模式用于对象之间的责任分配。它们定义了对象如何交互，以及如何分配责任。例如，观察者模式、策略模式等。</p>
</li>
</ol>
<p>设计模式不仅仅适用于特定的编程语言或技术，它们是一种通用的概念，可以在多种编程环境中应用。</p>
</blockquote>
<h2 id="设计模式一共包含23中，成为GOF23"><a href="#设计模式一共包含23中，成为GOF23" class="headerlink" title="设计模式一共包含23中，成为GOF23"></a>设计模式一共包含23中，成为GOF23</h2><h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><ol>
<li><strong>单例模式（Singleton）</strong>: 确保一个类只有一个实例，并提供一个全局访问点。</li>
<li><strong>工厂方法模式（Factory Method）</strong>: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li>
<li><strong>抽象工厂模式（Abstract Factory）</strong>: 提供一个接口，用于创建一系列相关或依赖对象，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder）</strong>: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype）</strong>: 创建新对象时，复制现有的实例。</li>
</ol>
<h3 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h3><ol start="6">
<li><strong>适配器模式（Adapter）</strong>: 允许不兼容的接口能够一起工作。</li>
<li><strong>桥接模式（Bridge）</strong>: 将抽象与实现分离，使它们可以独立地变化。</li>
<li><strong>组合模式（Composite）</strong>: 将对象组合成树形结构以表示“部分-整体”的层次结构。</li>
<li><strong>装饰器模式（Decorator）</strong>: 动态地给一个对象添加一些额外的职责。</li>
<li><strong>外观模式（Facade）</strong>: 提供一个统一的接口，用来访问一组接口。</li>
<li><strong>享元模式（Flyweight）</strong>: 使用共享对象来支持大量细粒度的对象。</li>
<li><strong>代理模式（Proxy）</strong>: 为其他对象提供一种代理以控制对这个对象的访问。</li>
</ol>
<h3 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h3><ol start="13">
<li><strong>责任链模式（Chain of Responsibility）</strong>: 将请求的发送者和接收者解耦。</li>
<li><strong>命令模式（Command）</strong>: 将请求封装为一个对象，从而使用户可用参数化请求的不同请求、队列请求，并提供额外的功能如记录请求日志。</li>
<li><strong>解释器模式（Interpreter）</strong>: 给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li>
<li><strong>迭代器模式（Iterator）</strong>: 提供一种方法顺序访问一个聚合对象中各个元素。</li>
<li><strong>中介者模式（Mediator）</strong>: 用一个中介对象来封装一系列对象之间的交互。</li>
<li><strong>备忘录模式（Memento）</strong>: 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
<li><strong>观察者模式（Observer）</strong>: 当一个对象状态改变时，它的所有依赖都会收到通知。</li>
<li><strong>状态模式（State）</strong>: 允许一个对象在其内部状态改变时改变它的行为。</li>
<li><strong>策略模式（Strategy）</strong>: 定义一系列算法，并将每一个算法封装起来。</li>
<li><strong>模板方法模式（Template Method）</strong>: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li>
<li><strong>访问者模式（Visitor）</strong>: 在不改变类的前提下，增加新的操作。</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>构造函数私有</li>
</ul>
<p>单例模式（Singleton Pattern）确保一个类只有一个实例，并提供一个全局访问点。在Java中，有多种实现单例模式的方式。以下是其中几种常见的方法：</p>
<h3 id="饿汉式（Eager-Initialization）"><a href="#饿汉式（Eager-Initialization）" class="headerlink" title="饿汉式（Eager Initialization）"></a>饿汉式（Eager Initialization）</h3><p>这种方式是在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。</p>
<pre><code class="java">public class Singleton &#123;
    private static final Singleton instance = new Singleton();

    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<ol>
<li><strong>资源共享</strong>：当你想确保某种资源（如配置管理、线程池）在整个应用中只被初始化和使用一次时，可以使用单例模式。</li>
<li><strong>频繁创建和销毁的对象</strong>：如果一个对象的创建和销毁成本很高，而且它经常被创建和销毁，那么使用单例模式可以提高性能，因为它只创建一次。</li>
<li><strong>全局状态管理</strong>：例如，你可能想跟踪应用中的某些全局状态，单例模式可以帮助你实现这一点。</li>
<li><strong>资源昂贵或初始化成本高</strong>：如果创建对象需要大量的计算、资源分配或其他高成本操作，那么使用单例可以确保这些操作只执行一次。</li>
<li><strong>需要确保状态一致性</strong>：如果你需要一个对象来维护某种全局状态或配置，并且你想确保在应用的任何地方都使用的是同一个状态或配置，那么单例模式是一个很好的选择。</li>
<li><strong>控制资源的访问</strong>：例如，如果你有一个需要多线程访问的资源（如数据库连接或文件），并且你想控制对该资源的访问，那么单例模式可以帮助你确保所有的线程都使用同一个资源实例。</li>
</ol>
<p>​	在Python中可以这样实现：</p>
<pre><code class="python">class Singleton:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 == s2)  # 输出 True，说明两个对象是同一个实例
</code></pre>
<p><strong>具体例子</strong>：</p>
<p>假设我们有一个配置管理器，它从一个配置文件中读取配置，并在整个应用中提供这些配置：</p>
<pre><code class="python">class ConfigManager(Singleton):
    def __init__(self):
        # 假设我们只在第一次初始化时加载配置
        if not hasattr(self, &#39;config&#39;):
            self.load_config()

    def load_config(self):
        # 这里只是一个简化的示例，实际应用中可能会从文件或数据库中加载配置
        self.config = &#123;
            &quot;api_key&quot;: &quot;YOUR_API_KEY&quot;,
            &quot;api_url&quot;: &quot;https://api.example.com/&quot;
        &#125;

    def get(self, key):
        return self.config.get(key)

# 测试
config1 = ConfigManager()
config2 = ConfigManager()

print(config1.get(&quot;api_key&quot;) == config2.get(&quot;api_key&quot;))  # 输出 True
print(config1 == config2)  # 输出 True
</code></pre>
<p>在这个例子中，无论我们创建多少次<code>ConfigManager</code>的实例，它们都是同一个实例，并且配置只加载一次。这确保了整个应用中的配置是一致的，并且我们不会浪费资源多次加载配置。</p>
<h3 id="懒汉式（Lazy-Initialization）"><a href="#懒汉式（Lazy-Initialization）" class="headerlink" title="懒汉式（Lazy Initialization）"></a>懒汉式（Lazy Initialization）</h3><p>这种方式是在首次请求对象时才完成初始化，所以类加载较快，但获取对象的速度可能较慢（特别是在多线程环境中）。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;

    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>当然可以。<code>synchronized</code>是Java中用于同步代码的关键字，它可以帮助我们在多线程环境中保持线程安全。</p>
<h3 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h3><p>在Java中，<code>synchronized</code>可以用于修饰方法或代码块。当一个方法或代码块被<code>synchronized</code>修饰时，它可以防止多个线程同时访问该方法或代码块，从而避免出现线程安全问题。</p>
<ol>
<li><p><strong>修饰方法</strong>：</p>
<pre><code class="java">public synchronized void synchronizedMethod() &#123;
    // 同步代码
&#125;
</code></pre>
</li>
<li><p><strong>修饰代码块</strong>：</p>
<pre><code class="java">public void method() &#123;
    synchronized(this) &#123;
        // 同步代码
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个简单的计数器类，它有一个<code>count</code>字段和一个<code>increment</code>方法来增加<code>count</code>的值：</p>
<pre><code class="java">public class Counter &#123;
    private int count = 0;

    public synchronized void increment() &#123;
        count++;
    &#125;

    public int getCount() &#123;
        return count;
    &#125;
&#125;
</code></pre>
<p>在这个例子中，<code>increment</code>方法是<code>synchronized</code>的，这意味着在任何时候只能有一个线程可以调用它。这确保了<code>count</code>字段的正确更新，即使在多线程环境中也是如此。</p>
<p>现在，让我们创建多个线程来同时调用<code>increment</code>方法：</p>
<pre><code class="java">public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Counter counter = new Counter();

        Thread thread1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 1000; i++) &#123;
                counter.increment();
            &#125;
        &#125;);

        Thread thread2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 1000; i++) &#123;
                counter.increment();
            &#125;
        &#125;);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println(&quot;Final count: &quot; + counter.getCount());  // 输出: Final count: 2000
    &#125;
&#125;
</code></pre>
<p>在这个例子中，即使<code>thread1</code>和<code>thread2</code>同时调用<code>increment</code>方法，<code>synchronized</code>关键字也确保了<code>count</code>字段的正确更新，因此最终的<code>count</code>值是2000，正如我们所期望的。</p>
<p>如果我们去掉<code>synchronized</code>关键字，那么输出就不一定是2000了，因为线程间的竞争条件可能会导致<code>count</code>字段被不正确地更新。</p>
<p>在Python中，我们可以使用<code>threading</code>模块中的<code>Lock</code>或<code>RLock</code>类来实现类似的同步机制。下面是一个简单的示例，说明如何使用<code>threading.Lock</code>来同步线程：</p>
<pre><code class="python">import threading

class Counter:
    def __init__(self):
        self.count = 0
        self.lock = threading.Lock()

    def increment(self):
        with self.lock:
            self.count += 1

    def get_count(self):
        return self.count

# 创建一个Counter对象
counter = Counter()

# 创建一个函数，该函数将在多个线程中运行，并调用Counter对象的increment方法
def worker():
    for _ in range(1000):
        counter.increment()

# 创建两个线程来运行worker函数
threads = []
for i in range(2):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()

# 等待所有线程完成
for t in threads:
    t.join()

# 打印最终的计数值
print(&quot;Final count:&quot;, counter.get_count())  # 输出: Final count: 2000
</code></pre>
<p>在这个示例中：</p>
<ul>
<li>我们创建了一个<code>Counter</code>类，它有一个<code>count</code>属性和一个<code>increment</code>方法来增加<code>count</code>的值。</li>
<li>我们使用<code>threading.Lock</code>来创建一个锁对象，并在<code>increment</code>方法中使用<code>with self.lock:</code>语句来自动获取和释放锁。这确保了在任何时候只有一个线程可以执行被锁保护的代码段。</li>
<li>我们创建了两个线程来并发调用<code>increment</code>方法。由于我们使用了锁来同步访问<code>count</code>属性，所以我们可以确保<code>count</code>属性被正确更新，即使在多线程环境中也是如此。</li>
</ul>
<p>这样，我们就实现了一个线程安全的计数器，它可以正确地在多线程环境中工作。</p>
</blockquote>
<p>这种方法的主要优点是，如果实例从未被请求，那么它将永远不会被创建，从而节省资源。</p>
<p>但是，需要注意的是，为了确保在多线程环境中的线程安全，我们使用了<code>synchronized</code>关键字，这可能会导致性能下降。</p>
<p>在Python中，懒汉模式可以这样实现：</p>
<pre><code class="python">class Singleton:
    _instance = None

    @classmethod
    def getInstance(cls):
        if not cls._instance:
            cls._instance = Singleton()
        return cls._instance

# 测试
s1 = Singleton.getInstance()
s2 = Singleton.getInstance()

print(s1 == s2)  # 输出 True，说明两个对象是同一个实例
</code></pre>
<blockquote>
<p>在Python中，<code>@classmethod</code>和<code>cls</code>是与类方法相关的概念：</p>
<ol>
<li><p><strong>@classmethod</strong>：</p>
<p>这是一个装饰器，用于指示紧随其后的方法是一个类方法。类方法与普通的实例方法不同，因为它们是针对类本身，而不是类的实例。这意味着你可以在没有创建类的实例的情况下调用类方法。</p>
<p>类方法的第一个参数总是指向类，而不是实例。这与实例方法的第一个参数总是指向实例（通常命名为<code>self</code>）形成对比。</p>
</li>
<li><p><strong>cls</strong>：</p>
<p>这只是一个参数名，通常用于类方法的第一个参数，表示类本身。你可以将其视为类的版本的<code>self</code>。虽然你可以为这个参数选择任何名称，但<code>cls</code>是一个广泛接受的命名约定。</p>
</li>
</ol>
<p>以下是一个简单的示例来说明这两个概念：</p>
<pre><code class="python">class MyClass:
    class_variable = &quot;I am a class variable&quot;

    @classmethod
    def print_class_variable(cls):
        print(cls.class_variable)

# 使用
MyClass.print_class_variable()  # 输出: I am a class variable
</code></pre>
<p>在上面的示例中，我们定义了一个类方法<code>print_class_variable</code>，它打印类变量<code>class_variable</code>。注意我们是如何直接使用类名<code>MyClass</code>来调用类方法的，而不需要创建类的实例。</p>
</blockquote>
<p><strong>具体例子</strong>：</p>
<p>假设我们有一个数据库连接管理器，它在首次请求时建立连接，并在整个应用中提供这个连接：</p>
<pre><code class="python">class DBConnectionManager(Singleton):
    def __init__(self):
        # 假设我们只在第一次初始化时建立连接
        if not hasattr(self, &#39;connection&#39;):
            self.connect_to_db()

    def connect_to_db(self):
        # 这里只是一个简化的示例，实际应用中可能会建立真实的数据库连接
        self.connection = &quot;DATABASE_CONNECTION&quot;

    def get_connection(self):
        return self.connection

# 测试
db1 = DBConnectionManager.getInstance()
db2 = DBConnectionManager.getInstance()

print(db1.get_connection() == db2.get_connection())  # 输出 True
print(db1 == db2)  # 输出 True
</code></pre>
<p>在这个例子中，无论我们创建多少次<code>DBConnectionManager</code>的实例，它们都是同一个实例，并且数据库连接只建立一次。这确保了整个应用中的数据库连接是一致的，并且我们不会浪费资源多次建立连接。</p>
<p>希望这次的解释和实现更为准确。再次为之前的错误向你道歉。</p>
<h3 id="双重检查锁定（Double-Checked-Locking）"><a href="#双重检查锁定（Double-Checked-Locking）" class="headerlink" title="双重检查锁定（Double-Checked Locking）"></a>双重检查锁定（Double-Checked Locking）</h3><p>这种方式结合了懒汉式和同步锁，以减少同步的开销。</p>
<pre><code class="java">public class Singleton &#123;
    private static volatile Singleton instance;

    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            synchronized (Singleton.class) &#123;
                if (instance == null) &#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>注意：这里使用了<code>volatile</code>关键字来确保多线程环境下的可见性。</p>
<h3 id="静态内部类（Static-Inner-Class）"><a href="#静态内部类（Static-Inner-Class）" class="headerlink" title="静态内部类（Static Inner Class）"></a>静态内部类（Static Inner Class）</h3><p>这种方式利用了Java的类加载机制来保证初始化实例时只有一个线程。</p>
<pre><code class="java">public class Singleton &#123;
    private Singleton() &#123;&#125;

    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;

    public static Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<p>这些只是单例模式在Java中的几种实现方式，每种方式都有其优缺点。根据你的具体需求，你可以选择最适合你的实现方式。如果你在SCI论文中需要讨论这方面的内容，了解这些不同的实现方式可能会很有帮助。</p>
<p>单例模式（饿汉模式 -&gt; 懒汉模式 -&gt; 双重检查机制(DCL) 	-&gt; volatile 双重检查</p>

    </div>
    
    
    
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 LinkedList&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Ding Li
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>


    
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv" style='display:none'>
                本站访客数<span id="busuanzi_value_site_uv"></span>人
        </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        


<script>
    Waline.init({
        el: "#waline-container",
        serverURL: "my-comment-tau.vercel.app",
        commentCount: true,
        pageview: false,
        emoji: "https://unpkg.com/@waline/emojis@1.2.0/weibo,https://unpkg.com/@waline/emojis@1.2.0/alus,https://unpkg.com/@waline/emojis@1.2.0/bilibili,https://unpkg.com/@waline/emojis@1.2.0/qq,https://unpkg.com/@waline/emojis@1.2.0/tieba,https://unpkg.com/@waline/emojis@1.2.0/tw-emoji".split(","),
        meta: "nick,mail,link".split(","),
        requiredMeta: "nick".split(","),
        lang: "zh-CN",
        wordLimit: 0,
        pageSize: "10",
        login: "enable",
        
    });
</script>



        
    </body>
</html>
